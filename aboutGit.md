# 01. Quick Git Grammar
## Git,그리고 GitHub
 내가 원하는 시점(버전)으로 이동할 수 있게 해주는 것이 버전관리이며, 이를 도와주는 툴이 버전관리 시스템이다.
 Git은 소스코드 버전 사이를 오가는 시간 여행 이상의 기능을 제공한다. Git은 저장할 공간만 있다면 어디서나 사용할 수 있다. 개인 컴퓨터에만 저장한다면 혼자서 사용할 수 있다.
만약 드롭박스, 구글 드라이브와 같은 클라우드 서버에 올려둔다면 팀 프로젝트를 하는 다른 팀원과 함께 인터넷을 통해 버전 관리를 할 수 있을 것이다.
 이렇게 Git으로 관리하는 프로젝트를 올려둘 수 있는 Git 호스팅 사이트 중 하나가 바로, GitHub이다.
### 기본적인 Git명령
* $git

* $git init
    - [.git]이라는 폴더가 생성되고 이것을 '로컬저장소'라고 부른다.
    - git init은 Git을 초기화하는 과정이다. 하나의 디렉터리에는 한 번만 git init을 하는 것이 좋다. 여러번 하면 꼬인다.

* $git config --global user.email "jinkh0129@naver.com"
* $git config --global user.name "jinkh0129"
    - GitHub의 계정 정보를 동일하게 입력하는 것이 좋다.

* $git add README.txt
    - README.txt라는 파일을 커밋에 추가하는 작업이다.
    - 버전은 저장이라고 이해하면 쉽다. 이렇게 생성된 각 버전을 커밋Commit이라고 부른다.

* $git commit -m "커밋메시지"jinkh0129
    - 커밋에는 상세 설명을 적을 수 있다. 설명을 잘 적어놓으면 내가 이 파일을 왜 만들었는지, 왜 수정했는지 알 수 있고, 해당 버전을 찾아 그 버전으로 코드를 바꿔 시간 여행을 하기도 수월하다.
    - m은 message의 약자이다.

* $git log
    - 커밋을 통해 우리는 언제든지 시간여행을 할 수 있다
    - 이전 커밋부터 다시 개발하고 싶다면 Git을 이용해 그 커밋으로 돌아가면 된다.
    - 돌아가기 위해 log명령어로 지금까지 만든 커밋을 확인한다.

* $git checkout (앞 7자리 커밋 아이디를 복사)
    - checkout 명령어로 해당 커밋으로 코드를 되돌릴 수 있다.

* $git checkout -
    - '-'를 적으면 최신 커밋으로 다시 돌아올 수 있다.

 [.git]폴더는 로컬저장소라고 부른다고 했다. 그렇다면 이제 GitHub에 협업할 공간은 '원격저장소'라고 부른다. 영어로는 Repository라고 한다. 이는 쉽게 말해서 GitHub 웹 사이트에 프로젝트를 위한 공용 폴더를 만드는 것이다.
  원격저장소를 만들고 주소를 복사했다면 내 컴퓨터의 로컬저장소에 알려주고, 로컬저장소에 만들었던 커밋들을 원격저장소에 올려야 한다.
* $git remote add origin https://GitHub.com/jinkh0129/iNoteElse.git
    - 로컬저장소에 원격저장소의 주소를 알려주는 것이다.

* $git push origin master
    - 로컬저장소에 있는 커밋들을 push 명령어로 원격저장소에 올리는 작업이다.
    - 이렇게 로컬저장소에서 만들었던 커밋들을 원격저장소에 올리는 작업을 푸시한다라고 한다.


## GitHub 원격저장소의 커밋을 로컬저장소에 내려받기
 원격저장소의 코드와 버전 전체를 내 컴퓨터로 내려받는 것을 클론(Clone)이라고 한다. 클론을 하면 최신 버전뿐만 아니라 이전 버전들과 원격저장소 주소 등이 내 컴퓨터의 로컬저장소에 저장이 된다.
* $git clone https://github.com/jinkh0129/iNoteElse.git .
    - 클론을 하려고 하는 폴더의 Git Bash를 켜서 입력해야 한다!(중요)
    - 마지막에 한 칸 띄우고 마침표(.)를 찍어주는 것이 중요하다. 마침표는 현재 폴더에 받으라는 뜻이다. 찍지 않으면 repo의 이름으로 하는 폴더가 1개 더 생겨서 복잡해질 수 있다.

### 원격저장소의 새로운 커밋을 로컬저장소에 갱신하기
* $git pull origin master
    - 원격저장소에 올렸던 커밋을 로컬저장소에 내려받아서 현재 상태를 갱신할 수 있다.
    - pull은 원격저장소에 새로운 커밋이 있다면 그걸 내 로컬저장소에 받아오라는 명령어이다.


# 혼자서 Git으로 버전 관리하기
## 로컬저장소를 소스트리에 불러오기
* clone : 원격저장소를 내 컴퓨터에 받아오고(로컬저장소 자동 생성됨), 소스트리에도 추가
* add : 내 컴퓨터에서 이미 만든 로컬저장소를 소스트리에 추가
* create : 내 컴퓨터의 폴더에 새로운 로컬저장소 생성하기(git init)
    - create를 할 때에는 기존에 초기화(git init)되지 않은 순수한 폴더를 선택해야 한다.

# 기본 개념 및 용어
## 용어 설명
* 로컬저장소 : 자신의 폴더에 git init을 통해 초기화해서 버전관리를 할 수 있는 저장공간을 의미한다. 혼자서 작업을 할 수 있다.
* 원격저장소 : GitHub에 만든 repository를 의미한다. 원격저장소를 통해 여러 사람들과 협업을 할 수 있다.
* 커밋(commit) : 버전을 저장하는 행위라고 생각하면 이해가 쉽다.
* 커밋메시지 : commit -m""에서 큰 따옴표 안에 들어가는 내용으로, 다른 사람들이 봐도 무슨 내용을 추가 혹은 수정했는지를 적어주면(작업의 구체적인 내용) 추적하기에 용이하다.
* origin : 우리가 연결한 GitHub 원격저장소의 닉네임이다.
    - $git remote add origin 원격저장소주소 --> origin이란 이름으로 원격저장소를 추가하라는 의미였다.
    - 원격저장소의 이름은 origin 대신에 myOrigin이렇게 변경해도 상관은 없다.
    - 소스트리에서 볼 수 있는 [origin]꼬리표는 원격저장소의 현재 버전 상태를 가리키는 커밋에 붙어있다고 할 수 있다.
* master : 우리가 커밋을 올리는 '줄기'의 이름이다. 따로 줄기를 생성하지 않으면 Git은 master라는 기본 줄기에 커밋을 올린다.
    - 소스트리에서 아무것도 붙지 않은 [master]는 내 컴퓨터 로컬저장소의 버전을, 앞에 origin이 붙은 [origin/master]는 GitHub 원격저장소의 버전을 가리키는 것이다.
    - 즉 git push origin master는 현재 줄기인 master의 모든 새로운 커밋을 원격저장소 origin에 올리겠다는 의미다.

## Git으로 관리하는 파일의 4가지 상태
1. Git 초기화(git init)을 하고 파일을 만들었다. 이 파일은 한 번도 커밋되지 않은 파일이기 때문에 (파일상태)를 보면 '추적 안됨(Untracked)'이다.
2. add 명령어를 통해 두 파일 모두 스테이지에 올린다. (파일 상태)가 '추적안됨'에서 '스테이지됨(staged)'로 변경된다.
3. 스테이지에 있는 파일 전체를 commit 명령어를 통해 하나의 버전으로 만들었다. (파일 상태)가 '스테이지됨'에서 '수정 없음(unmodified)'로 변경되었다. 
4. 커밋이 로컬저장소에만 있으면 나밖에 버전관리를 못 하니까 다른 사람도 함께 하기 위해 push 명령어를 써서 원격저장소에 올린다.
5. 푸시한 파일을 수정해서 (파일 상태)를 '수정없음'에서 '수정함(modified)'로 변경한다. 또 commit을 사용해서 스테이지에 올리고 push를 사용해서 원격저장소에 올릴 수 있다.
* UNTRACKED(추적안됨) / TRACKED(UNMODIFIED(수정 없음),MODIFIED(수정됨),STAGED(스테이지됨)) --> 4가지 파일상태

# 여러 명이 함께 Git으로 협업하기
## 원격저장소에서 협업하기 : 브랜치(Branch)
 특정 기준에서 줄기를 나누어 작업할 수 있는 기능을 브랜치(branch)라고 한다. 새로운 가지로 커밋을 만들려면 반드시 브랜치를 먼저 만들어야 한다.
 master는 Git이 제공하는 기본적인 브랜치이다.
 왜 [master]브랜치에 커밋을 '올린다'라고 하지 않고 '가리킨다'라는 표현을 쓸까? 이것은 브랜치가 나뭇가지처럼 물리적으로 '길'이 존재해서 그 길에 올리는 것이 아니라 단순한 '포인터'이기 때문이다.
새로 커밋을 할 때마다 [master]브랜치의 포인터가 최신 커밋을 가리킨다.
 브랜치가 포인터라는 것은 그저 커밋을 가리키는 것만으로도 분기를 만들 수 있다는 장점이 있다.
 그럼 내 컴퓨터에서 여러 브랜치 사이를 어떻게 넘나들 수 있는 것일까? 바로 [HEAD]라는 특수한 포인터 그 비법이다. 브랜치 혹은 커밋을 가리키는 포인터이다. 우리는 [HEAD]를 이용해서 브랜치 사이를 마음대로 넘나들 수 있다. [HEAD]가 [master]브랜치를 가리키고 있으면 [master]브랜치가 가리키는 커밋의 상태를 보여준다. 브랜치의 최신 커밋이 아닌 과거 커밋으로도 [HEAD]를 이동시킬 수 있다. 다만, 이런 경우에는 [master]브랜치의 포인터와 [HEAD]가 떨어져있기에 '분리된 HEAD(Detached HEAD)'상태가 된다.

* 하나의 개발 브랜치에는 한 사람만 작업해서 올리는 것이 바람직하다.
    - 그렇기 때문에 여러 사람이 작업하는 원격저장소에는 미리 브랜치 규칙을 정하는 것이 일반적이다.
(ex)
1. [master]브랜치에는 직접 커밋을 올리지 않는다(동시에 작업하다 꼬일 수 있으니)
2. 기능 개발을 하기 전에 [master]브랜치를 기준으로 새로운 브랜치를 만든다
3. 이 브랜치 이름은 [feature/기능이름]형식으로 하고 한 명만 커밋을 올린다.
4. [feature/기능이름]브랜치에서 기능 개발이 끝나면 [master]브랜치에 이를 합친다.

* 브랜치를 만들 때는 base 브랜치를 잘 설정해야 한다.
    - Tip) 브랜치 이름 앞에 [origin/]이 붙었으면 원격저장소에도 잘 올라갔다는 의미이다.

 즉 각자의 브랜치에서 개발을 하다가 각자의 개발이 완료되면 [master]브랜치에 내 브랜치 작업물을 합치면 된다. [master]브랜치를 기준으로 만든 브랜치니 [master]브랜치를 큰 줄기로 잡고 잔가지에서 조금씩 수정해서 다시 큰 줄기에 합치는 것이다.

 ## 브랜치와 브랜치를 합치기 : 병합(merge,머지)
 병합(merge)는 간단히 말해서 두 버전의 합집합을 구하는 것이다.
 1. Merge Commit(병합 커밋)
 2. Fast-forward(빨리 감기)
 3. Conflict(충돌)
 
 ## 둘이 똑같은 코드를 고쳤을 때 : 충돌(conflict)해결하기
  행여 두 커밋이 서로 같은 코드를 수정했다면 병합 커밋을 만들다가 충돌이 날 가능성이 있다. 그래서 동료들과 같이 쓰는 [master]브랜치에 바로 병합하지 않고 나만 쓰는 브랜치에서 먼저 병합을 해 보고 문제가 없는지 확인한다. 문제가 없으면 [master]브랜치에 병합 커밋을 반영하면 된다.
  
## 브랜치를 합치는 예의바른 방법 : 풀 리퀘스트
 '풀 리퀘스트(pull request)'는 협력자에게 브랜치 병합을 요청하는 메시지를 보내는 것이다. 풀 리퀘스트, 즉 정중하게 병합을 요청할 수 있는 메시지를 적을 수 있는 페이지가 나온다. 베이스 브랜치와 비교 브랜치를 설정해야 한다. 병합 결과물이 올라갈, 즉 기준이 되는 브랜치가 베이스 브랜치입니다.

 ## 개발이 완료되었습니다. 출시하자 : 릴리즈(release)
 프로그램의 버전을 올리는 것은 크게 메이저(Major)업그레이드와 마이너(Minor)업그레이드로 나뉜다. 사용자들이 크게 느낄 변화를 적용했을 때 보통 메이저 버전을 올리고(v2.x -> v3.x), 작은 변화들이 생겼을 땐 마이너 버전을 올립니다(v2.3->v2.4).
 프로그램을 출시하는 것을 릴리즈(release)라고 한다. 병합을 마친 [master]브랜치를 서버에 올려서 사용자들이 쓸 수 있도록 배포하고, 현재 코드 상태를 버전 v1.0.0이라고 기록하려고 한다. 이때 태그(tag)를 통해 간단하게 표시할 수 있다.